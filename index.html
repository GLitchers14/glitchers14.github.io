<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GLitchers14 (ANGLE Review Tracker)</title>
<style>
  :root{--bg:#0b0f13;--panel:#121822;--border:#1f2a37;--text:#e5eef6;--sub:#92a3b5;--accent:#5eead4;--muted:#74869a}
  html,body,#root{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px}
  .row{display:flex;align-items:center;gap:8px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  .btn{border:1px solid var(--border);border-radius:10px;padding:6px 10px;background:#0f141b;color:var(--text);cursor:pointer}
  input{background:#0f141b;border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;outline:none}
  .grid{display:grid;grid-template-columns:1fr 2fr; gap:16px}
  @media (max-width:1100px){.grid{grid-template-columns:1fr}}
  .tree{max-height:72vh;overflow:auto}
  .fullpath{word-break:break-all}
  .badge{font-size:12px;color:var(--sub)}
  .donut{width:140px;height:140px}
  .dirrow{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:8px;user-select:none}
  .filerow{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 8px;border-radius:8px}
  .caret{display:inline-block;width:1em;text-align:center}
  .switch{position:relative;display:inline-block;width:44px;height:24px}
  .switch input{opacity:0;width:0;height:0}
  .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#243142;border:1px solid var(--border);transition:.2s;border-radius:999px}
  .slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;top:2px;background:#d0d8e3;transition:.2s;border-radius:50%}
  .switch input:checked + .slider{background:#0b2a22;border-color:#134e4a}
  .switch input:checked + .slider:before{transform:translateX(20px)}
  .btable{width:100%;border-collapse:separate;border-spacing:0 6px;margin-top:12px}
  .bname{white-space:nowrap}
  .bbar{height:10px;background:#14202a;border:1px solid #233645;border-radius:999px;overflow:hidden}
  .bfill{height:100%;background:linear-gradient(90deg,#0ea5e9,#22c55e)}
  .bright{font-variant-numeric:tabular-nums}
  footer.footer{margin:14px auto 10px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div id="root">
  <div class="wrap">
    <h1>ANGLE Review Tracker — GLitchers14</h1>

    <div class="card" style="margin-bottom:12px">
      <div class="row" style="flex-wrap:wrap;gap:10px">
        <span class="badge">repo</span>
        <input id="repo" class="mono" style="min-width:240px" placeholder="owner/repo" value="google/angle"/>
        <span class="badge">branch</span>
        <input id="branch" class="mono" style="min-width:120px" placeholder="main" value="main"/>
        <button id="apply" class="btn">Apply</button>
        <span id="shaBadge" class="badge"></span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2 style="margin-top:6px">Progress</h2>
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div>
            <div class="row"><span class="badge">Total </span><span id="total" class="mono">—</span></div>
            <div class="row"><span class="badge">Reviewed</span><span id="rev" class="mono">—</span></div>
            <div class="row"><span class="badge">Percent</span><span id="pctText" class="mono">—%</span></div>
          </div>
          <svg id="donut" class="donut" viewBox="0 0 120 120" aria-label="progress donut">
            <circle cx="60" cy="60" r="50" fill="none" stroke="#16202b" stroke-width="14"></circle>
            <circle id="donutFill" cx="60" cy="60" r="50" fill="none" stroke="var(--accent)" stroke-width="14"
                    stroke-dasharray="314.159" stroke-dashoffset="314.159" transform="rotate(-90 60 60)"></circle>
            <text id="donutText" x="60" y="66" text-anchor="middle" font-size="20" font-weight="700" fill="#cde9ff">—%</text>
          </svg>
        </div>

        <h3 style="margin:12px 0 6px">Backends</h3>
        <table class="btable" id="backendTable" aria-label="backend progress table"></table>

        <div id="err" style="white-space:pre-wrap;color:#fecaca;margin-top:8px"></div>
      </div>

      <div class="card tree">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
          <h2 style="margin:0">ANGLE Source Tree</h2>
          <label class="row" title="Only show files that are not reviewed yet" style="gap:10px">
            <span class="badge">show only unchecked</span>
            <span class="switch"><input type="checkbox" id="onlyU"/><span class="slider"></span></span>
          </label>
        </div>
        <div id="tree"></div>
      </div>
    </div>

    <footer class="footer">
      <p>© 2025 tb4nch0r · All rights reserved.</p>
    </footer>
  </div>
</div>

<script>
const GH_VER = '2022-11-28';
const LS_DB = 'angle-review-tracker/whitelist-tree.v4';
const STATE_ENDPOINT = '/state';
const $ = id => document.getElementById(id);

// 서버 기본값과 형식 맞춤
const DEFAULT_DB = {
  repo: 'google/angle',
  branch: 'main',
  reviews: {},
  manual: [],
  meta: { version: 7, updatedAt: 0 }
};

function norm(p){
  return String(p||'')
    .replace(/^third_party\/angle\//,'')
    .replace(/^angle\//,'')
    .replace(/^\/+/, '');
}
function base(p){
  const i = String(p).lastIndexOf('/');
  return i >= 0 ? p.slice(i+1) : String(p);
}
function clone(o){ return JSON.parse(JSON.stringify(o)); }

function loadDB(){
  try{
    const raw = localStorage.getItem(LS_DB);
    if(!raw) return clone(DEFAULT_DB);
    const parsed = JSON.parse(raw);
    parsed.meta = parsed.meta || {};
    if(typeof parsed.meta.version !== 'number') parsed.meta.version = 7;
    if(typeof parsed.meta.updatedAt !== 'number') parsed.meta.updatedAt = 0;
    if(!parsed.manual) parsed.manual = [];
    if(!parsed.reviews) parsed.reviews = {};
    return parsed;
  }catch{
    return clone(DEFAULT_DB);
  }
}

let syncTimer = null;

function saveDB(db){
  db.meta = db.meta || {};
  db.meta.version = 7;
  db.meta.updatedAt = Date.now();
  localStorage.setItem(LS_DB, JSON.stringify(db));
  scheduleStateSync();
}

function scheduleStateSync(){
  if(syncTimer) clearTimeout(syncTimer);
  syncTimer = setTimeout(doStateSync, 500);
}

async function doStateSync(){
  syncTimer = null;
  try{
    const payload = {
      repo: DB.repo || 'google/angle',
      branch: DB.branch || 'main',
      reviews: DB.reviews || {},
      manual: DB.manual || [],
      meta: {
        version: 7,
        updatedAt: Date.now()
      }
    };
    const res = await fetch(STATE_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const j = await res.json().catch(()=>null);
    if(!res.ok || !j || j.ok !== true){
      console.warn('[state-sync] failed', res.status, j);
    }else if(j.applied === false){
      console.info('[state-sync] server rejected as stale');
    }
  }catch(e){
    console.warn('[state-sync] error', e);
  }
}

const LEGACY_LS_KEYS = [
  'angle-review-tracker/db.whitelist.v1',
  'angle-review-tracker/db.whitelist.v2',
  'angle-review-tracker/whitelist-tree.v1',
  'angle-review-tracker/whitelist-tree.v2',
  'angle-review-tracker/whitelist-tree.v3'
];

// reviews: { "path": true } 또는 { "path": {checked:true} } 둘 다 지원
function mergeReviewsIntoDB(fromObj){
  if(!fromObj || typeof fromObj !== 'object') return;

  const src = (fromObj.reviews && typeof fromObj.reviews === 'object')
    ? fromObj.reviews
    : {};

  DB.reviews = DB.reviews || {};

  for(const k in src){
    const v = src[k];

    const isChecked = (v === true) || (v && v.checked === true);
    if(!isChecked) continue;

    const nk = norm(k);
    const ts = (v && typeof v === 'object' && v.ts)
      ? v.ts
      : new Date().toISOString();

    DB.reviews[nk] = { checked: true, ts };
  }

  saveDB(DB);
}

async function tryImportServerStateOnce(){
  try{
    const r1 = await fetch('data/state.json', { cache: 'no-store' });
    if(r1.ok){
      const obj = await r1.json();
      if(obj && obj.reviews){ mergeReviewsIntoDB(obj); return true; }
    }
  }catch{}
  try{
    const r2 = await fetch('/state', { cache: 'no-store' });
    if(r2.ok){
      const obj = await r2.json();
      if(obj && obj.reviews){ mergeReviewsIntoDB(obj); return true; }
    }
  }catch{}
  try{
    const r3 = await fetch('data/reviews.json',{cache:'no-store'});
    if(r3.ok){
      const obj = await r3.json();
      if(obj && obj.reviews){ mergeReviewsIntoDB(obj); return true; }
    }
  }catch{}
  try{
    const r4 = await fetch('data/db.json',{cache:'no-store'});
    if(r4.ok){
      const obj = await r4.json();
      if(obj && obj.reviews){ mergeReviewsIntoDB(obj); return true; }
    }
  }catch{}
  return false;
}

async function importLegacyOnce(){
  let imported = false;
  for(const key of LEGACY_LS_KEYS){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) continue;
      mergeReviewsIntoDB(JSON.parse(raw));
      imported = true;
    }catch{}
  }
  const s = await tryImportServerStateOnce();
  imported = imported || s;
  return imported;
}

let DB = loadDB();
let SHA = null;
let WL_FILES = [];
let TREE = null;

function gh(path){
  const u = 'https://api.github.com/' + String(path).replace(/^\/+/, '');
  return fetch(u, {
    headers: {
      'Accept': 'application/vnd.github+json',
      'X-GitHub-Api-Version': GH_VER
    },
    cache: 'no-store'
  }).then(async r=>{
    if(r.ok) return r.json();
    const body = await r.text().catch(()=> '');
    const msg = `GitHub API ${r.status} ${r.statusText}\nURL: ${u}\n${body.slice(0,300)}`;
    const errBox = $('err');
    if(errBox) errBox.textContent = msg;
    return null;
  }).catch(e=>{
    const errBox = $('err');
    if(errBox) errBox.textContent = `fetch failed: ${e}`;
    return null;
  });
}

async function resolveSHA(owner,repo,branch){
  const j = await gh(`repos/${owner}/${repo}/git/refs/heads/${encodeURIComponent(branch)}`);
  if(j && j.object && j.object.sha) return j.object.sha;
  return branch;
}

const WL_INCLUDE_DIRS = [
  'src/compiler/translator/','src/libANGLE/','src/libANGLE/renderer/d3d/','src/libANGLE/renderer/gl/','src/libANGLE/renderer/vulkan/','src/libANGLE/renderer/metal/',
  'angle/src/compiler/translator/','angle/src/libANGLE/','angle/src/libANGLE/renderer/d3d/','angle/src/libANGLE/renderer/gl/','angle/src/libANGLE/renderer/vulkan/','angle/src/libANGLE/renderer/metal/'
];
const WL_DENY_SUBDIRS = [
  'src/compiler/translator/ir/','src/compiler/translator/msl/','src/compiler/translator/tree_ops/','src/compiler/translator/apple/','src/compiler/translator/tree_util/','src/compiler/translator/wgsl/','src/compiler/translator/capture/',
  'angle/src/compiler/translator/ir/','angle/src/compiler/translator/msl/','angle/src/compiler/translator/tree_ops/','angle/src/compiler/translator/apple/','angle/src/compiler/translator/tree_util/','angle/src/compiler/translator/wgsl/','angle/src/compiler/translator/capture/',
  'src/libANGLE/capture/','angle/src/libANGLE/capture/',
  'src/libANGLE/renderer/cl/','src/libANGLE/renderer/null/','src/libANGLE/renderer/wgpu/','angle/src/libANGLE/renderer/cl/','angle/src/libANGLE/renderer/null/','angle/src/libANGLE/renderer/wgpu/',
  'src/libANGLE/renderer/vulkan/android/','src/libANGLE/renderer/vulkan/fuchsia/','src/libANGLE/renderer/vulkan/null/','src/libANGLE/renderer/vulkan/win32/',
  'src/libANGLE/renderer/vulkan/linux/display/','src/libANGLE/renderer/vulkan/linux/gbm/','src/libANGLE/renderer/vulkan/linux/headless/','src/libANGLE/renderer/vulkan/linux/healess/','src/libANGLE/renderer/vulkan/linux/wayland/','src/libANGLE/renderer/vulkan/linux/xcb/',
 'src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp',
  'src/libANGLE/renderer/vulkan/CLContextVk.cpp',
  'src/libANGLE/renderer/vulkan/CLDeviceVk.cpp',
  'src/libANGLE/renderer/vulkan/CLEventVk.cpp',
  'src/libANGLE/renderer/vulkan/CLKernelVk.cpp',
  'src/libANGLE/renderer/vulkan/CLMemoryVk.cpp',
  'src/libANGLE/renderer/vulkan/CLPlatformVk.cpp',
  'src/libANGLE/renderer/vulkan/CLProgramVk.cpp',
  'src/libANGLE/renderer/vulkan/CLSamplerVk.cpp',
  'src/libANGLE/renderer/vulkan/clspv_utils.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLContextVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLDeviceVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLEventVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLKernelVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLMemoryVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLPlatformVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLProgramVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/CLSamplerVk.cpp',
  'angle/src/libANGLE/renderer/vulkan/clspv_utils.cpp',
  'angle/src/libANGLE/renderer/vulkan/android/','angle/src/libANGLE/renderer/vulkan/fuchsia/','angle/src/libANGLE/renderer/vulkan/null/','angle/src/libANGLE/renderer/vulkan/win32/',
  'angle/src/libANGLE/renderer/vulkan/linux/display/','angle/src/libANGLE/renderer/vulkan/linux/gbm/','angle/src/libANGLE/renderer/vulkan/linux/headless/','angle/src/libANGLE/renderer/vulkan/linux/healess/','angle/src/libANGLE/renderer/vulkan/linux/wayland/','angle/src/libANGLE/renderer/vulkan/linux/xcb/',
  'src/libANGLE/renderer/gl/cgl/','src/libANGLE/renderer/gl/egl/','src/libANGLE/renderer/gl/egl/android/','src/libANGLE/renderer/gl/glx/','src/libANGLE/renderer/gl/wgl/',
  'angle/src/libANGLE/renderer/gl/cgl/','angle/src/libANGLE/renderer/gl/egl/','angle/src/libANGLE/renderer/gl/egl/android/','angle/src/libANGLE/renderer/gl/glx/','angle/src/libANGLE/renderer/gl/wgl/',
  'src/libANGLE/renderer/metal/file_hooking','angle/src/libANGLE/renderer/metal/file_hooking'
];

function inInclude(p){ return WL_INCLUDE_DIRS.some(pre => p.startsWith(pre)); }
function inDeny(p){ return WL_DENY_SUBDIRS.some(pre => p.startsWith(pre)); }
function isCppOrMM(p){ return /\.(cpp|mm)$/i.test(p); }
function allowedPath(raw){
  const p = norm(raw);
  return inInclude(p) && !inDeny(p) && isCppOrMM(p);
}

function setDonut(pct){
  const c = 2*Math.PI*50;
  if(typeof pct !== 'number'){
    $('donutFill').setAttribute('stroke-dashoffset', String(c));
    $('donutText').textContent = '—%';
    $('pctText').textContent = '—%';
    return;
  }
  $('donutFill').setAttribute('stroke-dashoffset', String(c*(1-pct)));
  const t = Math.round(pct*100);
  $('donutText').textContent = t + '%';
  $('pctText').textContent = t + '%';
}

function buildTree(paths){
  const root = { name:'', type:'dir', children:new Map(), total:0, rev:0, full:'' };

  function addPath(p){
    const parts = p.split('/');
    let cur = root;
    const acc = [];
    for(let i=0;i<parts.length;i++){
      const name = parts[i];
      acc.push(name);
      const last = (i === parts.length-1);
      if(last){
        cur.children.set(name, {
          name, type:'file',
          full: acc.join('/'),
          total:1, rev:0
        });
      }else{
        if(!cur.children.has(name)){
          cur.children.set(name, {
            name, type:'dir',
            children:new Map(),
            full: acc.join('/'),
            total:0, rev:0
          });
        }
        cur = cur.children.get(name);
      }
    }
  }

  paths.forEach(addPath);

  function fold(n){
    if(n.type === 'file'){
      n.rev = isReviewed(n.full) ? 1 : 0;
      n.total = 1;
      return;
    }
    let t=0, r=0;
    const kids = [...n.children.values()].sort((a,b)=>{
      if(a.type !== b.type) return a.type === 'dir' ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
    n.childrenList = kids;
    kids.forEach(k => { fold(k); t += k.total; r += k.rev; });
    n.total = t;
    n.rev = r;
  }

  fold(root);
  return root;
}

function renderTree(){
  const holder = $('tree');
  holder.innerHTML = '';

  function renderNode(node, parent){
    if(node.type === 'file'){
      const row = document.createElement('div');
      row.className = 'filerow';

      const left = document.createElement('label');
      left.className = 'row';
      left.style.minWidth = '0';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = isReviewed(node.full);
      cb.addEventListener('change', e => mark(node.full, e.target.checked));

      const name = document.createElement('span');
      name.className = 'mono fullpath';
      name.textContent = node.name;

      left.appendChild(cb);
      left.appendChild(name);

      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = cb.checked ? '✅ reviewed' : '⬜ unchecked';
      cb.addEventListener('change', ()=>{
        badge.textContent = cb.checked ? '✅ reviewed' : '⬜ unchecked';
      });

      row.appendChild(left);
      row.appendChild(badge);
      parent.appendChild(row);
      return;
    }

    const box = document.createElement('div');
    const head = document.createElement('div');
    head.className = 'dirrow';

    const caret = document.createElement('span');
    caret.className = 'caret';
    caret.textContent = '▸';

    const title = document.createElement('span');
    title.style.fontWeight = '600';
    title.textContent = node.name || '/';

    const count = document.createElement('span');
    count.className = 'badge';
    count.textContent = `${node.rev}/${node.total} files reviewed`;

    head.appendChild(caret);
    head.appendChild(title);
    head.appendChild(count);

    const body = document.createElement('div');
    body.style.marginLeft = '18px';
    body.style.display = 'none';

    let open = false;
    head.addEventListener('click', ()=>{
      open = !open;
      caret.textContent = open ? '▾' : '▸';
      body.style.display = open ? '' : 'none';
    });

    box.appendChild(head);
    box.appendChild(body);
    parent.appendChild(box);

    (node.childrenList || []).forEach(ch => renderNode(ch, body));

    box.__count = count;
    box.__body = body;
    box.__node = node;
  }

  renderNode(TREE, holder);
  applyOnlyUnchecked();
}

function applyOnlyUnchecked(){
  const onlyU = $('onlyU').checked;

  function walk(node, el){
    if(node.type === 'file'){
      el.style.display = (!onlyU || !isReviewed(node.full)) ? '' : 'none';
      return;
    }
    const body = el.__body;
    const kids = node.childrenList || [];
    let shown = 0;
    for(let i=0;i<kids.length;i++){
      const childEl = body.children[i];
      walk(kids[i], childEl);
      if(childEl.style.display !== 'none') shown++;
    }
    el.style.display = shown > 0 ? '' : 'none';
    el.__count.textContent = `${node.rev}/${node.total} files reviewed`;
  }

  const rootEl = $('tree').children[0];
  if(rootEl) walk(TREE, rootEl);
}

const BACKENDS = {
  d3d:   { label:'D3D',   prefix:'src/libANGLE/renderer/d3d/'   },
  metal: { label:'Metal', prefix:'src/libANGLE/renderer/metal/' },
  vulkan:{ label:'Vulkan',prefix:'src/libANGLE/renderer/vulkan/'}
};

function computeBackendStats(){
  const stats = {};
  for (const k in BACKENDS) stats[k] = { total: 0, rev: 0 };

  const wlSet = new Set(WL_FILES);

  for (const p of WL_FILES) {
    for (const k in BACKENDS) {
      const pref = BACKENDS[k].prefix;
      if (p.startsWith(pref)) {
        stats[k].total++;
        if (isReviewed(p)) stats[k].rev++;
        break;
      }
    }
  }

  if (DB.reviews) {
    for (const rawKey in DB.reviews) {
      const v = DB.reviews[rawKey];
      if (!v || !v.checked) continue;

      const p = norm(rawKey);
      if (wlSet.has(p)) continue;
      if (!isCppOrMM(p)) continue;
      if (!inInclude(p) || inDeny(p)) continue;

      for (const k in BACKENDS) {
        const pref = BACKENDS[k].prefix;
        if (p.startsWith(pref)) {
          stats[k].total++;
          stats[k].rev++;
          break;
        }
      }
    }
  }

  return stats;
}

function renderBackendTable(){
  const tbl = $('backendTable');
  tbl.innerHTML = '';
  const s = computeBackendStats();

  for(const k of ['d3d','metal','vulkan']){
    const st = s[k];
    const label = BACKENDS[k].label;
    const pct = st.total ? Math.round(st.rev*100/st.total) : 0;

    const tr = document.createElement('tr');

    const tdL = document.createElement('td');
    tdL.className = 'bname mono';
    tdL.textContent = label;

    const tdM = document.createElement('td');
    tdM.style.width = '100%';
    const bar = document.createElement('div');
    bar.className = 'bbar';
    bar.title = `${label}: ${st.rev}/${st.total} (${pct}%)`;
    const fill = document.createElement('div');
    fill.className = 'bfill';
    fill.style.width = pct + '%';
    bar.appendChild(fill);
    tdM.appendChild(bar);

    const tdR = document.createElement('td');
    tdR.className = 'bright mono';
    tdR.style.whiteSpace = 'nowrap';
    tdR.textContent = `${pct}%  (${st.rev}/${st.total})`;

    tr.appendChild(tdL);
    tr.appendChild(tdM);
    tr.appendChild(tdR);
    tbl.appendChild(tr);
  }
}

function recalcAndPaint(){
  function fold(n){
    if(n.type === 'file'){
      n.rev = isReviewed(n.full) ? 1 : 0;
      return;
    }
    let r = 0;
    (n.childrenList || []).forEach(k => { fold(k); r += k.rev; });
    n.rev = r;
  }
  fold(TREE);

  $('total').textContent = WL_FILES.length || '—';
  const reviewed = WL_FILES.reduce((a,p)=>a + (isReviewed(p)?1:0), 0);
  $('rev').textContent = (reviewed || WL_FILES.length) ? reviewed : '—';
  setDonut(WL_FILES.length ? (reviewed / WL_FILES.length) : null);
  renderBackendTable();
  applyOnlyUnchecked();
}

function isReviewed(p){
  const k = norm(p);
  return !!(DB.reviews && DB.reviews[k] && DB.reviews[k].checked);
}

function mark(p, checked){
  const k = norm(p);
  if(checked){
    DB.reviews[k] = { checked:true, ts:new Date().toISOString() };
  }else{
    delete DB.reviews[k];
  }
  saveDB(DB);
  recalcAndPaint();
}

function setErr(msg){
  $('err').textContent = msg || '';
}

function addCheckedExtrasNotInWhitelist(){
  const extras = [];
  if(DB.reviews){
    for(const k in DB.reviews){
      if(DB.reviews[k] && DB.reviews[k].checked){
        const p = norm(k);
        if(!p.includes('/')) continue;
        if(!isCppOrMM(p)) continue;
        if(!inInclude(p) || inDeny(p)) continue;
        if(!WL_FILES.includes(p)) extras.push(p);
      }
    }
  }
  if(extras.length){
    WL_FILES = Array.from(new Set(WL_FILES.concat(extras))).sort();
  }
}

// ★ numeric key → 경로 기반 key로 마이그레이션
function migrateIndexReviewsToPaths(){
  if(!DB.reviews) return;
  const keys = Object.keys(DB.reviews);
  if(!keys.length) return;

  const numericKeys = keys.filter(k => /^[0-9]+$/.test(k));
  if(!numericKeys.length) return;

  const newReviews = {};

  // 1) 비숫자 키(이미 경로 기반)는 그대로 보존
  for(const k of keys){
    if(!/^[0-9]+$/.test(k)){
      newReviews[k] = DB.reviews[k];
    }
  }

  // 2) 숫자 키는 WL_FILES 인덱스로 매핑
  numericKeys.sort((a,b)=>parseInt(a,10)-parseInt(b,10));
  for(const k of numericKeys){
    const idx = parseInt(k, 10);
    if(idx < 0 || idx >= WL_FILES.length) continue;
    const path = WL_FILES[idx];        // 화이트리스트에서 실제 경로
    const nk = norm(path);
    const v = DB.reviews[k];
    const ts = (v && typeof v === 'object' && v.ts)
      ? v.ts
      : new Date().toISOString();
    newReviews[nk] = { checked:true, ts };
  }

  DB.reviews = newReviews;
  saveDB(DB);   // 마이그레이션 결과를 localStorage + /state에 반영
}

async function loadWhitelistAndRender(){
  setErr('');
  const val = $('repo').value.trim();
  const br  = $('branch').value.trim();
  if(!val || !val.includes('/')) throw new Error('repo 형식은 owner/repo');
  if(!br) throw new Error('branch 필요');

  const [owner,repo] = val.split('/');
  const sha = await resolveSHA(owner,repo,br);
  SHA = sha;
  $('shaBadge').textContent = 'pinned '+(sha||'').slice(0,7);

  const t = await gh(`repos/${owner}/${repo}/git/trees/${sha}?recursive=1`);
  const all = (t && t.tree) ? t.tree : [];
  WL_FILES = all
    .filter(e => e && e.type === 'blob' && allowedPath(e.path || ''))
    .map(e => norm(e.path || ''))
    .sort();

  // numeric index → path 마이그레이션
  migrateIndexReviewsToPaths();

  addCheckedExtrasNotInWhitelist();

  TREE = buildTree(WL_FILES);
  renderTree();
  recalcAndPaint();
}

$('apply').addEventListener('click', async ()=>{
  try{
    DB.repo = ($('repo').value || '').trim();
    DB.branch = ($('branch').value || '').trim();
    saveDB(DB);
    await loadWhitelistAndRender();
  }catch(e){
    setErr(String(e));
  }
});

$('onlyU').addEventListener('change', applyOnlyUnchecked);

(async function init(){
  $('repo').value = DB.repo;
  $('branch').value = DB.branch;
  await importLegacyOnce();
  await loadWhitelistAndRender();
})();
</script>
</body>
</html>

